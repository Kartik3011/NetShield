import os
import assemblyai as aai
import streamlit as st
import tempfile 
import yt_dlp # CRITICAL: Direct import to bypass subprocess/shell errors
import time # Time import is needed for the sleep function

# Set the AssemblyAI API key from Streamlit secrets
try:
    aai.settings.api_key = st.secrets["ASSEMBLYAI_API_KEY"]
except KeyError:
    st.error("ASSEMBLYAI_API_KEY not found in st.secrets.")
    aai.settings.api_key = "DUMMY_KEY" 

# --- NEW/MODIFIED FUNCTION TO CLEAN COOKIE DATA AND ENSURE NETSCAPE HEADER ---
def clean_cookies(raw_cookies: str) -> str:
    """Aggressively cleans the cookie string to ensure strict Netscape format."""
    
    # 1. Define the mandatory Netscape header lines
    NETSCAPE_HEADER = [
        "# Netscape HTTP Cookie File",
        "# This file is generated by NetShield for yt-dlp.",
        "" 
    ]
    
    lines = raw_cookies.splitlines()
    cookie_entries = []
    
    # 2. Filter out all non-cookie lines and keep only valid entries
    for line in lines:
        stripped_line = line.strip()
        # Keep only lines that look like valid domain entries, starting with a dot
        if stripped_line and stripped_line.startswith('.'):
             # Keep the original line spacing/tabs
             cookie_entries.append(line) 
             
    # 3. Prepend the official Netscape header to the collected entries
    final_output_lines = NETSCAPE_HEADER + cookie_entries
             
    # 4. Join them back together with a standard newline. 
    return '\n'.join(list(final_output_lines)) 
# -------------------------------------------------------------------


def download_youtube_audio(youtube_url, i=0):
    """
    Downloads audio from a YouTube URL using yt-dlp, handling cookies and temporary files.
    """
    temp_dir = tempfile.gettempdir()
    cookies_path = os.path.join(temp_dir, f"cookies_{i}.txt")
    final_output_path = os.path.join(temp_dir, f"video_{i}_audio.mp3")

    try:
        # 1. Retrieve and clean raw cookie data
        raw_cookie_data = st.secrets["YOUTUBE_COOKIES"]
        cleaned_cookie_data = clean_cookies(raw_cookie_data)
        
        # 2. Write cleaned cookie data to a temporary file
        with open(cookies_path, 'w', encoding='utf-8') as f:
            f.write(cleaned_cookie_data)
            
        # 3. Configuration for yt-dlp library
        ydl_opts = {
            # --- START CRITICAL PO TOKEN BYPASS ---
            # Force using the web client, which is sometimes more lenient than default
            'extractor_args': ['youtube:client=web'],
            # Skip checking for supported JS runtime (avoids the "No supported Javascript runtime" warning)
            'skip_download': False, 
            'no_check_formats': True,
            # --- END CRITICAL PO TOKEN BYPASS ---
            
            # ADDING VERBOSE: TRUE TO GET DETAILED DEBUG OUTPUT
            'verbose': True, 
            
            # Request a specific, stable audio format
            'format': 'bestaudio[ext=m4a]/bestaudio', 
            'extract_audio': True, 
            'audioformat': "mp3", 
            'outtmpl': final_output_path, 
            'noplaylist': True,
            'quiet': False, # Setting quiet to False is REQUIRED for verbose output
            'cookiefile': cookies_path, 
            'writethumbnail': False,
            'postprocessors': [{
                'key': 'FFmpegExtractAudio',
                'preferredcodec': 'mp3',
                'preferredquality': '192',
            }],
        }

        print(f"Downloading audio from: {youtube_url} to {final_output_path}")
        
        # 4. Execute download using the yt-dlp library
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            ydl.download([youtube_url])
        
        
        # 5. CRITICAL FINAL CHECK: Verify file existence
        if os.path.exists(final_output_path):
            print(f"Audio downloaded and saved as {final_output_path}")
            return final_output_path
        else:
            print(f"Download completed, but final file not found at {final_output_path}.")
            # Log the formats yt-dlp found for debugging
            print("--- FORMATS FOUND (Final Check) ---")
            try:
                info = ydl.extract_info(youtube_url, download=False)
                for f in info.get('formats', []):
                    if f.get('ext') in ('m4a', 'mp3', 'webm'):
                         print(f"ID: {f.get('format_id')}, Ext: {f.get('ext')}, VCodec: {f.get('vcodec')}, ACodec: {f.get('acodec')}, Size: {f.get('filesize')}")
            except Exception as e:
                print(f"Could not retrieve format info for final check: {e}")

            return None

    except yt_dlp.utils.DownloadError as e:
        print(f"yt-dlp Download Error: {e}")
        return None
    except Exception as e:
        print(f"An unexpected error occurred during audio download setup: {e}")
        return None
    finally:
        # 6. Clean up: Delete the temporary cookies file
        if os.path.exists(cookies_path):
            os.remove(cookies_path)


@st.cache_data(show_spinner=False)
def transcript(url, video_index):
    """
    Downloads audio and transcribes it using AssemblyAI.
    This is the main function called by other pages.
    """
    print(f"Starting transcription for video index: {video_index}")
    
    # 1. Download the audio file
    audio_path = download_youtube_audio(url, i=video_index)
    
    if not audio_path or not os.path.exists(audio_path):
        return "Audio download failed."
        
    try:
        # 2. Perform the transcription
        transcriber = aai.Transcriber()
        config = aai.TranscriptionConfig(language_code="en")
        
        transcript_obj = transcriber.transcribe(audio_path, config=config)
        
        if transcript_obj.status == aai.TranscriptStatus.error:
             return f"Transcription failed with error: {transcript_obj.error}"
        
        return transcript_obj.text if transcript_obj.text else "Transcription returned empty text."
        
    except Exception as e:
        print(f"AssemblyAI transcription failed: {e}")
        return f"Transcription service error: {e}"
        
    finally:
        # 3. Clean up the downloaded audio file
        if os.path.exists(audio_path):
            os.remove(audio_path)
